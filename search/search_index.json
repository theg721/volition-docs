{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>&lt;- Back to GH Repo</p>"},{"location":"#welcome-to-mkdocs","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"SR2/","title":"Saints Row 2","text":""},{"location":"SR2/filelist/","title":"File list","text":"<pre><code>Saints Row 2\n\u251c\u2500\u2500 anims.vpp_pc\n\u251c\u2500\u2500 audio.vpp_pc\n\u251c\u2500\u2500 bitmaps_pc\n\u251c\u2500\u2500 chunks1.vpp_pc\n\u251c\u2500\u2500 chunks2.vpp_pc\n\u251c\u2500\u2500 chunks3.vpp_pc\n\u251c\u2500\u2500 chunks4.vpp_pc\n\u251c\u2500\u2500 city_load.vpp_pc\n\u251c\u2500\u2500 common.vpp_pc\n\u251c\u2500\u2500 CrashReporter\n\u251c\u2500\u2500 CrashReporter.i386\n\u251c\u2500\u2500 CrashReporter.x86_64\n\u251c\u2500\u2500 cutscenes.vpp_pc\n\u251c\u2500\u2500 data\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 DFEngine\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 cache\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 data\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Default\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Default.tga\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 df.dat\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 tiger\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 df.dat\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 tiger.x\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 objects.dfo\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 engine.var\n\u251c\u2500\u2500 filelist.txt\n\u251c\u2500\u2500 hmaps.vpp_pc\n\u251c\u2500\u2500 icon.png\n\u251c\u2500\u2500 icudt52l.dat\n\u251c\u2500\u2500 legal\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 freetype.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 glew.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 HLSLCrossCompiler.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ICU License - ICU 1.8.1 and later.html\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 LGPL v2.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 libcurl.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 LibTomCrypt.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 licenses.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 TomsFastMath.txt\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 zlib.txt\n\u251c\u2500\u2500 libavcodec-eon_full.so.56\n\u251c\u2500\u2500 libavformat-eon_full.so.56\n\u251c\u2500\u2500 libavutil-eon_full.so.54\n\u251c\u2500\u2500 libopenal-eon.so.1\n\u251c\u2500\u2500 meshes.vpp_pc\n\u251c\u2500\u2500 music1.vpp_pc\n\u251c\u2500\u2500 music2.vpp_pc\n\u251c\u2500\u2500 music3.vpp_pc\n\u251c\u2500\u2500 music4.vpp_pc\n\u251c\u2500\u2500 patch.vpp_pc\n\u251c\u2500\u2500 pegs.vpp_pc\n\u251c\u2500\u2500 preload_anim.tbl\n\u251c\u2500\u2500 preload.tbl\n\u251c\u2500\u2500 saferun.sh\n\u251c\u2500\u2500 saintsrow2\n\u251c\u2500\u2500 saintsrow2.i386\n\u251c\u2500\u2500 saintsrow2.vpfs\n\u251c\u2500\u2500 SDLGamepad.config\n\u251c\u2500\u2500 shaders\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2d_notex.vso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2d_tex.vso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 lit_notex.pso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 lit_notex.vso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 lit_tex.pso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 lit_tex.vso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 notex_nolight.pso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 notex.pso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 resolve_depth.pso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 resolve_depth_rawz.pso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 resolve_depth_rawz.vso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 resolve_depth.vso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 tex_flat.pso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 tex_flat.vso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 tex.pso_pc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 transform_notex.vso_pc\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 transform_tex.vso_pc\n\u251c\u2500\u2500 shaders_pc\n\u251c\u2500\u2500 steam_appid.txt\n\u251c\u2500\u2500 textures.vpp_pc\n\u251c\u2500\u2500 videos\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 br08-01-screen.bik\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 escort_university_webcam.bik\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 limo_footage_green.bik\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 logo_thq_hd.bik\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 logo_volition_hd.bik\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 StrongArm_Tutorial.bik\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 TSSE-Intro-Presentation.bik\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 TSSP-INTRO-pt1.bik\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 vista_final_1.bik\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 vista_final_2.bik\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 vista_final_3.bik\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 vista_final_4.bik\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 vista_final_5.bik\n\u2514\u2500\u2500 voice_pc\n</code></pre>"},{"location":"SR2/formats/","title":"Formats","text":"Name Ext. Description Tools Car <code>.car_pc</code> a vehicle <code>cmesh2obj</code> Chunkfile <code>.chunk_pc</code> <code>.g_chunk_pc</code> World data <code>SR2_Chonker</code> <code>SR2_ChunksTextureTool</code> Cityfile <code>.city_pc</code> Chunk directory Coordinate <code>.cts</code> World coords for CD's and more <code>SR2_CTS_Mapper</code> cvtf <code>.cvtf</code> Customization Mesh <code>.cmesh_pc</code> <code>.g_cmesh_pc</code> <code>.smesh_pc</code> <code>.g_smesh_pc</code> <code>cmesh2obj</code> Packfile <code>.vpp_pc</code> File container archive <code>minimaul's tools</code> Pegfile <code>.peg_pc</code> <code>.g_peg_pc</code> Image data <code>SR2_PegTool</code> <code>SR2_ChunksTextureTool</code> Table <code>.tbl</code> XML Table <code>.xtbl</code>"},{"location":"SR2/formats/Peg/","title":"Pegfiles","text":"<p>File extensions</p> <p><code>.peg_pc</code> <code>.g_peg_pc</code> </p>"},{"location":"SR2/formats/chunkfiles/","title":"Chunkfiles","text":"<p>File extensions</p> <p><code>.chunk_pc</code> <code>.g_chunk_pc</code> </p>"},{"location":"SR2/formats/chunkfiles/#info","title":"Info","text":"<p>The .chunk_pc file internally shares a lot of formats with other files.</p> <ul> <li> <p>Things found in chunkfiles:</p> <ul> <li>Materials</li> <li>Static Objects</li> <li>Object models</li> <li>Baked world collision</li> <li>Light sources</li> <li></li> </ul> </li> <li> <p>Not yet found but expected:</p> <ul> <li>Traffic paths</li> </ul> </li> </ul>"},{"location":"SR2/formats/chunkfiles/#gpu-models","title":"GPU Models","text":"<p>Every visible model is in the g_chunk file. The format for static models is figured out.</p>"},{"location":"SR2/formats/chunkfiles/#cpu-models","title":"CPU Models","text":"<p>The chunk_pc file itself contains models too, with no UV's or other extra data. Labeled as physmodels, since they're probably collision for loose objects.</p>"},{"location":"SR2/formats/chunkfiles/#objects","title":"Objects","text":"<p>For some reason the objects is split into two structs, located very far apart in the file.</p>"},{"location":"SR2/formats/chunkfiles/#world-collision","title":"World Collision","text":"<p>Collision for all static objects in a chunk seem to be baked into one Havok collision blob. Look up Havok MOPP for some info from other mod scenes, though there isn't much.</p>"},{"location":"SR2/formats/chunkfiles/#chunk_pc-layout","title":".chunk_pc Layout","text":""},{"location":"SR2/formats/chunkfiles/#header","title":"Header","text":"<p>256B header</p> Header Offset Type Name Comment 0x0 u32 magic 0x4 u32 version always 121 0x8 0xC u32 (unused) always 0 0x10 ... ... ... ... 0x94 u32 cityobject_count 0x98 u32 unknown23_count 0x9C 0xA0 0xA4 0xA8 0xAC 0xB0 0xB4 u32 mesh_mover_count 0xB8 u32 unknown27_count 0xBC u32 unknown28_count 0xC0 u32 unknown29_count 0xC4 u32 unknown30_count 0xC8 u32 unknown31_count 0xCC 0xD0 0xD4 f32 These look like world coords. 0xD8 f32 0xDC f32 0xE0 f32 0xE4 f32 0xE8 f32 0xEC f32 0xF0 0xF4 0xF8 0xFC chunk_pc header<pre><code>int32       signature;      //\nint32       version;        // Version 121\nint32       unknown_0x8;    // \nint32       unused_0xc;     // always 0\n</code></pre>"},{"location":"SR2/formats/chunkfiles/#texture-list","title":"Texture list","text":"<p>Filename of each texture used in the chunk. Always starts at 0x100 as the header is fixed length. Size 16-byte aligned</p> chunk_pc texturelist<pre><code>int32       num_textures;               //\nuint32      padding[num_textures];      //\nchar        texture_names[num_textures];//\n&lt;alignment padding 16&gt;                  //\n</code></pre>"},{"location":"SR2/formats/chunkfiles/#g_chunk_pc-layout","title":".g_chunk_pc layout","text":""},{"location":"SR2/formats/cityfiles/","title":"Cityfile","text":"<p>File extensions</p> <p><code>.city_pc</code></p> <p>The city file is some kind of directory that tells the game about chunks.</p> <p>Header</p> <p></p>"},{"location":"SR2/lua/","title":"Lua","text":"<p>TODO: Pull all lua reference</p>"},{"location":"SRIV/formats/anim/","title":"Animation Formats","text":"Links <ul> <li>[V] RabbleRooster | Crunched Animation Formats</li> </ul> Tools <p>-</p> <p>[QUOTE=\"[V] RabbleRooster, post: 100706, member: 44315\"] This post is like the mesh one, except I should understand these better (although, quite frankly, everything has changed since then). </p> <p>Rigs are the listing of bones, their parents, and the positional relationship in a T-pose (there's no rotation data in a crunched rig): <pre><code>struct anim_tag {\nV_FILE_PTR(char *)    name;\net_fl_matrix43            transformation;\net_int                    parent_index;\net_int                    vid;\n};\n// base bone\nclass anim_bone {\npublic:\nV_FILE_PTR(char *)    name;\net_fl_vector            inv_translation;        //Relative to the skin pivot\net_fl_vector            rel_bone_translation;    //Relative to the parent\net_int                    parent_index;\net_int                    vid;\n};\nclass anim_rig {\npublic:   char                name[ANIMLIB_MAX_ANIM_RIG_NAME_LEN];\net_uint            flags;\net_int            num_bones;\net_int            num_common_bones;\net_int            num_virtual_bones;\net_int            num_tags;\nV_FILE_PTR(uint32 *)    bone_name_chksums;\nV_FILE_PTR(anim_bone    *) bones;\nV_FILE_PTR(anim_tag *)  tags;\n};\n</code></pre></p> <p>Here's the header for the anim file: <pre><code>#define AFF_PACKED_KEYS                    (1&lt;&lt;0) // tightly packed rotation keys\n#define AFF_TIME_AS_SHORTS                (1&lt;&lt;1) // time is stored as shorts instead of chars\n#define AFF_DELTA_TIMES                    (1&lt;&lt;2) // animation times are stored as deltas\n#define AFF_HAS_MOTION                    (1&lt;&lt;3) // animation has motion information\n#define AFF_HAS_MORPH                    (1&lt;&lt;4) // animation has morph information\n#define AFF_LONG_TRANSLATIONS            (1&lt;&lt;5) // animation has animated bones that extend beyond 512 meters\n#define AFF_HAS_WEIGHT_KEYS            (1&lt;&lt;6) // animation has weight keys\n#define AFF_SHORT_COUNTS                (1&lt;&lt;7) // animation has more than 255 rotation or translational keyframes\n#define AFF_HAS_SCALE_KEYS                (0) // animation has scale keys\nstruct anim_file {\net_int32        id;\nuint8            version;\nuint8            flags; // see AFF_* above\net_uint16    end_frame;\nuint8            ramp_in;                        // ramp in  (in MAX ticks)\nuint8            ramp_out;                    // ramp out (in MAX ticks)\nuint8            num_bones;                    // number of animated bones (those with keyframes - even if identity)\nuint8            num_rig_bones;                // num_rig_bones when anim was crunched.\net_fl_quaternion        total_rotation;\net_fl_vector            total_translation;\nV_FILE_PTR(uint8 *) anim_to_rig_bone_mapping;    // array of size ANIM_LIB_CFG_MAX_BONES\nV_FILE_PTR(uint8 *) root_controller_bone;        // pointer to the bone data for the root controller.  All other bones have to be stepped through in code\nuint8            data[0];\n};\n</code></pre></p> <p>The actual animation key data is packed in some really funky ways (spelling mistakes and all).  Here are the relevant types: <pre><code>struct char_quat {\nint8 x, y, z;\n};\n// a packed rotation offset\n// a b and c components represent the 3 smallest values of a quaternion.\n#if defined(__PC)\nstruct afc_rotation_offset {\nint8 a                    : 6;\nuint8 a_scaler_bits    : 2;\nint8 b                    : 6;\nuint8 b_scaler_bits    : 2;\nint8 c                    : 6;\nuint8 c_scaler_bits    : 2;\nuint8 count                : 6;\nuint8 largest            : 2;\n};\n#else\nstruct afc_rotation_offset {\nuint8 a_scaler_bits    : 2;\nint8 a                    : 6;\nuint8 b_scaler_bits    : 2;\nint8 b                    : 6;\nuint8 c_scaler_bits    : 2;\nint8 c                    : 6;\nuint8 largest            : 2;\nuint8 count                : 6;\n};\n#endif\n// data is packed into 4 6 bit values.\n// easiest way to retrieve is to cast data to an int pointer and copy, then do manipulation\n// xbox2:    | x:6 bits | y:6 bits | z:6 bits | time:6 bits | junk: 8 bits |\n// pc/ps3:    | junk: 8 bits | x:6 bits | y:6 bits | z:6 bits | time:6 bits |\n// byte 0 : | x:6  |y:2|\n// byte 1 : | y:4 | z:4|\n// byte 2 : |z:2|time:6|\n// in order to preserve the sign bit, first shift all the bits to the far left before shifting 26 bits back to the far right. (26 = 32 - 6)\nclass afc_rotation_key_packed {\nprivate:\nuint8 data[3];\npublic:\ninline int get_time() {\nreturn (data[2] &amp; 0x3f);\n};\ninline int get_a() {\nreturn (((int)(data[0] &lt;&lt; 24)) &gt;&gt; 26);\n};\ninline int get_b() {\nreturn (((int)((data[0] &lt;&lt; 30) | ((data[1] &amp; 0xf0) &lt;&lt; 22))) &gt;&gt; 26);\n};\ninline int get_c() {\nreturn (((int)((data[1] &lt;&lt; 28) | ((data[2] &amp; 0xc0) &lt;&lt; 20))) &gt;&gt; 26);\n};\n};\nstruct afc_rotation_key {\nchar_quat rotation;\n};\n// in millimeter units, so a char can represent +/- 127 millimeters\nstruct afc_translation_key {\nchar x;\nchar y;\nchar z;\n};\n// in 1 / 64 meter units, so a short can represent +/- 512 meters\nstruct afc_translation_offset {\nuint16 num_keys;\nint16 x;\nint16 y;\nint16 z;\n};\nstruct afc_translation_offset_long {\nuint32 num_keys;\nint32 x;\nint32 y;\nint32 z;\n};\nstruct afc_scale_key {\nfl_vector scale;\n};\nstruct afc_weight_key {\nfloat weight;\n};\nstruct afc_morph_key {\nuint8 weight;\n};\n</code></pre></p> <p>If there is interest, I can do a bit to demystify the storage of all this data in the future.</p> <p>Here's the data structures for cloth sim files (there may be some header before the main cloth_sim_info struct):</p> <pre><code>struct simulated_node_info {\nint8 bone_index;\nint8 parent_node_index;    // rotation is applied to the parent bone for each particle\nint8 gravity_link;\nint8 anchor;\nuint32 collide;        // binary list of colliders that this node collides with.\nfloat wind_multiplier;\nxxx_vector_conv pos;\nxxx_vector_conv local_space_pos;\n};\nstruct simulated_node_link_info {\nuint16 node_index_1;\nuint16 node_index_2;\nuint32 collide;        // bit list of colliders that this linke collides with\nfloat    length;\nfloat stretch_len;\nfloat twist;\nfloat spring;\nfloat damp;\n};\nstruct cloth_sim_collision_primitive_info {\nint    bone_index;\nshort    is_capsule;\nshort    do_scale;\nfloat    radius;\nfloat    height;\nxxx_vector_conv pos;\nxxx_vector_conv axis;\nxxx_vector_conv local_space_pos;\n};\nstruct cloth_sim_rope_info {\nfloat    length;\nint    num_nodes;\nint    num_links;\nint    *node_indecies;\nint    *link_indecies;\n};\nstruct cloth_sim_info {\nint    version;\nint    data_size;\nchar  name[28];\nint    num_passes;\nfloat    air_resistance;\nfloat wind_multiplier;\nfloat wind_const;   float    gravity_multiplier;\nfloat object_velocity_inheritance;\nfloat object_position_inheritance;\nfloat object_rotation_inheritance;\nint    wind_type;\nint    num_nodes;\nint    num_anchor_nodes;\nint    num_node_links;\nint    num_ropes;\nint    num_colliders;\nsimulated_node_info                *nodes;\nsimulated_node_link_info        *node_links;\ncloth_sim_rope_info                *ropes;\ncloth_sim_collision_primitive_info *colliders;\n};\n</code></pre> <p>Finally, I'll add morph information here: <pre><code>struct rl_morph_target_data {\net_uint                                    name_chksum;\net_uint                                    num_vbuffers;\nV_FILE_PTR(rl_morph_buffer_generic *) vbuffers; //type is given by target_format in parent structure\n};\nstruct rl_morph_data {\net_int                            signature;\net_int                            version;\net_int                            target_format;\net_int                            num_targets;\nV_FILE_PTR(rl_morph_target_data *) targets;\n};\nclass rl_morph_container : public rl_base_object {\nprotected:\nuint32    m_debug_signature;\nrl_morph_data                *m_morph_data;\n};\nstruct mesh_morph {\net_int                        signature;\net_int                        version;\nV_FILE_PTR(rl_morph_container *)    morph_target;\n};\n</code></pre></p>"},{"location":"SRIV/formats/meshes/","title":"Mesh Formats","text":"Links <ul> <li>[V] RabbleRooster | Crunched Mesh Formats</li> </ul> Tools <p>-</p> <p>cmesh and smesh share the same structure, called static_mesh (not confusing). The cpu file gets a <code>v_file_header</code>, followed by:</p> <ul> <li>static_mesh</li> <li>Texture names</li> <li>Navpoints</li> <li>Collision spheres</li> <li>Collision cylinders</li> <li>Rig bone indices</li> <li>Mesh data</li> <li>Materials</li> <li>VIDs</li> <li>submesh LOD info</li> </ul> <p>The relevant structures for static_mesh: <pre><code>// Navigation reference point\nstruct static_mesh_navp {\nchar                            name[MAX_NAVP_NAME_LENGTH];            // name to reference nav point by\net_int                        vid;                                            // vid this navp is attached to.\net_fl_vector                pos;                                            // position of navpoint in object coords\net_fl_quaternion            orient;                                        // quaternion representation of navpoint\n};\nstruct cmesh_csphere {\net_uint32        body_part_id;                // ID for the body part this represents\net_int            parent_index;                // index of parent bone (-1 if none)     \net_fl_vector    pos;                            // position of collision sphere in object coords \net_float            radius;                        // radius of collision sphere\n};\nstruct cmesh_ccylinder {\net_uint32        body_part_id;                // ID for the body part this represents\net_int            parent_index;\net_fl_vector    axis;\net_fl_vector    pos;\net_float            radius;\net_float            height;\n};\nclass static_mesh {\npublic:\net_int                        signature;\net_short                        version;\net_short                        mesh_flags;\n// grouping the various count fields together to minimize padding waste\net_short                        num_navpoints;\net_short                        num_rig_bones;                                // Number of bones this character mesh uses from the RIG file.\net_short                        num_materials;                                // number of entries in materials array\net_short                        num_material_maps;                        // number of entries in material_maps and material_map_name_crcs arrays\net_short                        num_lods_per_submesh; //number of lods per submesh. All submeshes must have same number of lods, currently.\net_uint16                        num_submesh_vids;    //this will be &gt;= num_logical_submeshes (there can be additional vids tacked on the end purely for informational reasons)\nV_FILE_PTR(static_mesh_navp *) navpoints;                                    // prop points, I think.\nV_FILE_PTR(et_uint *)    rig_bone_indices;                        // List of RIG bone indices used by this character mesh.\net_fl_vector                bounding_center;                            // for some reason, these are only in VIF meshes.\net_float                        bounding_radius;\n// collision primitives for inter-character hit detection\net_short                        m_num_cspheres;                            // collider spheres used for hit detection\net_short                        m_num_ccylinders;                            // collider cylinders used for hit detection\n// 4 BYTES PADDING IF V_FILE_PTR is 8 bytes\nV_FILE_PTR(cmesh_csphere *)    m_cspheres;\nV_FILE_PTR(cmesh_ccylinder *) m_ccylinders;\n// rendering mesh data\nV_FILE_PTR(rl_mesh *)         mesh;\n//NOTE: It is possible for material_maps and materials to be NULL. That means the materials are expected to be provided externally.\nV_FILE_PTR(V_FILE_PTR(rl_material_map*) *)       material_maps;                            // num_material_maps sized array of material maps\nV_FILE_PTR(et_uint32 *)                                 material_map_name_crcs;                // num_material_maps sized array of name crc for each material map\nV_FILE_PTR(V_FILE_PTR(rl_static_material *) *)   materials;                                // num_materials sized array of materials\n//logical number of submeshes (same as actual number of submeshes only if we don't have lods)\net_uint32               num_logical_submeshes;\n// 4 BYTES PADDING IF V_FILE_PTR is 8 bytes\n//This pointer will either be null (no VID info) or will point to an array of ints of length num_logical_submeshes\n//It will contain the VID corresponding to each logical submesh\nV_FILE_PTR(et_uint32 *) submesh_vids;\n//This pointer will either be null (no LOD info) or will point to a (flat) 2D array, representing the rl_mesh submesh indexes for each lod level of each \"logical submesh\"\n//submesh_lod_info[logical_submesh_index*num_lods_per_submesh + lod_level] --&gt; index into rl_mesh's flat array of submeshes.\nV_FILE_PTR(et_short *)  submesh_lod_info;\n};\n</code></pre></p> <p>The CPU mesh data itself has a little header information: [LIST] []Version (uint16 + 4 byte pad) []CRC to validate mapping with the GPU file (uint32) []CPU size (uint32) []GPU size (uint32) [/LIST] Then we get the data:</p> <pre><code>struct rl_vertex_buffer_data\n{\net_int32                       num_verts;           // number of vertices in the buffer\nuint8                           vert_stride_0;       // stride (size) of each vertex (stream 0)\nuint8                           vertex_format;       // vertex format\nuint8                           num_uv_channels;   // number of uv channels (from 0 to 4)\nuint8                           vert_stride_1;       // stride (size) of each vertex (stream 1)\nV_FILE_PTR(void *)      render_data;     // pointer to platform specific data we need for this vertex buffer (created at run-time)\nV_FILE_PTR(rl_mesh_generic_vertex *) verts;\n};\nstruct rl_index_buffer_data\n{\net_uint32                    num_indices;            // number of indices in the index buffer\n// 4 BYTE PAD WHEN V_FILE_PTR IS 8 BYTES\nV_FILE_PTR(rl_generic_index *) indices;        // can be either et_uint16 or et_uint32\nuint8                            index_size;                // size of indices in bytes (2 or 4)\nuint8                            prim_type;                // keep it 4 byte aligned\net_uint16                    num_blocks;\n};\nstruct rl_bone_group_data\n{\nuint8                            num_group_bones;        // How many entries in the mapped_bone_list this group uses.\nuint8                            group_bone_offset;    // Index in the mapped_bone_list of the first bone in this group.\n};\nstruct rl_bone_map_data\n{\net_uint16                    num_mapped_bones;\n// 2 BYTES OR 6 BYTES PAD DEPENDING ON V_FILE_PTR SIZE\nV_FILE_PTR(uint8 *)        mapped_bone_list;\net_uint16                    num_bone_groups;\n// 2 BYTES OR 6 BYTES PAD DEPENDING ON V_FILE_PTR SIZE\nV_FILE_PTR(rl_bone_group_data *) bone_group_list;\n};\nstruct rl_mesh_data\n{\net_uint32                            mesh_flags;\net_int32                                num_sub_meshes;\nV_FILE_PTR(rl_submesh_data *) sub_meshes;\net_uint32                            num_vertex_buffers;\n// 4 BYTE PAD WHEN V_FILE_PTR IS 8 BYTES\nV_FILE_PTR(rl_vertex_buffer_data *) vertex_buffers;\nrl_index_buffer_data                index_buffer;\nrl_bone_map_data                    bone_map;\n//                these were moved out of vertex buffer data structure when we put in\n//                multiple vertex formats, because it does not make sense to have different\n//                scales/offsets for different vertex buffers on the same mesh.\net_fl_vector                        position_scale;    // scale to apply to vertex positions\net_fl_vector                        position_offset;    // offset to apply to vertex positions\n};\n</code></pre> <p>Vertex format will be one of these (most likely float3 or xcposition): <pre><code>enum rl_vertex_attribute_type {\nRLVA_INVALID_TYPE = -1,\n////////////////////////\n// Floating Point Types\nRLVAT_FLOAT1 = 0,\nRLVAT_FLOAT2,\nRLVAT_FLOAT3,\nRLVAT_FLOAT4,\n////////////////////////\n// Half Float Types\nRLVAT_HALF2,\nRLVAT_HALF4,\n////////////////////////\n// Byte Types\nRLVAT_UBYTE4,\nRLVAT_UBYTE4N,\n////////////////////////\n// Short Types\nRLVAT_SHORT2N,\nRLVAT_SHORT4N,\nRLVAT_SHORT2,\nRLVAT_SHORT4,\n////////////////////////\n// Compressed Normal Meta Types\nRLVAT_CNORMAL,\nRLVAT_CTANGENT,\n////////////////////////\n// Color Meta Types\nRLVAT_COLOR4,\n////////////////////////\n// Compressed Position Meta Types\nRLVAT_CPOSITION,\nRLVAT_XCPOSITION,\nNUM_RL_VERTEX_ATTRIBUTE_TYPES\n};\n</code></pre></p> <p>lmesh files are for level meshes. They also get a v file header, then this header structure: <pre><code>struct level_mesh_aux_data {\net_fl_bbox                    m_bbox;\n// these are flags stored about the entries. There are num_prims/2 bytes in this array.\n// Each nibble has the information for a single primitive with the least\n// significant bit having the first primitive's flags, ie, ((m_flags[i]) &amp; 0xF) = first primitive\n// (flag &amp; 0xF0) &gt;&gt; 4 = second primitive\nuint8                            m_flags[0];\n};\nstruct level_mesh_subinstance {\npublic:\net_fl_matrix43          m_transform;\net_uint16               m_submesh_index;\net_uint16               m_flags;\n};\nstruct level_mesh_zbias_decal {\npublic:\net_fl_matrix43                m_transform;\net_int                        m_decal_layer;\net_uint32                    m_mesh_index;\n};\nstruct level_mesh_stitch_edge {\npublic:\net_uint32            m_num_knots;\nV_FILE_PTR(et_fl_vector *)    m_knots;\n};\nstruct level_mesh_posdummy {\net_int               m_type;       // use level_mesh_posdummy_types\net_fl_matrix43       m_transform;\n};\nstruct level_mesh_occluder {\net_vm_matrix44 m_transform;\net_vm_bbox m_aabb;\n};\nstruct level_mesh_lod_array {\nstatic const int max_lods = 3;\nlevel_mesh_lod_array()\n{\nfor (int i = 0; i &lt; max_lods; i++) {\nm_lods[i] = NULL;\nm_variant_values[i] = NULL;\n}\nm_level_mesh_name[0]=0;\n}\nrl_multi_mesh_instance::lod* m_lods[max_lods];\nlevel_mesh_variant_value *m_variant_values[max_lods];\nlinked_list_p&lt;level_mesh_header&gt; m_level_meshes[max_lods];\n// debug cursor (which also works in release) name\nstatic const int max_name_len = 48;\nchar m_level_mesh_name[max_name_len];\n};\nstruct level_mesh_material_variant {\net_uint32 m_material_name_checksum;\net_uint16 m_variant_0_id;\net_uint16 m_variant_1_id;\n};\nclass level_mesh_header {\npublic:\net_uint32                    m_signature;\net_uint16                    m_version;\n// 2 BYTES PADDING\net_uint32                    m_flags;\net_fl_vector                m_bounding_center;                         et_float                        m_bounding_radius;\net_vm_bbox                    m_local_aabb;\n// :ANDYC:TODO: remove when zbias decals are part of multi mesh instance\n// :BEGIN REMOVE LATER:\nstruct {\n// rendering mesh data\n// 4 BYTES PADDING IF V_FILE_PTRS are 8 bytes\nV_FILE_PTR(V_FILE_PTR(rl_mesh *)*)    m_base_meshes;\net_uint32                    m_num_base_meshes;\nV_FILE_PTR(V_FILE_PTR(rl_material_map *) *)    m_base_material_maps;\net_uint32                    m_num_base_material_maps;\n// 4 BYTES PADDING IF V_FILE_PTRS are 8 bytes\nV_FILE_PTR(const char *)    m_texture_names;\nV_FILE_PTR(level_mesh_zbias_decal *)    m_zbias_decals;\net_uint32                    m_num_zbias_decals;\n} m_decals;\n// :END REMOVE LATER:\net_int32                        m_cm_index;\net_int32                        m_corpse_cm_index;\nV_FILE_PTR(hkpShape*)    m_static_collision_model;\net_int32                        m_num_stitch_edges;\nV_FILE_PTR(level_mesh_stitch_edge *) m_stitch_edges;\net_int32                m_num_posdummies;\n// 4 BYTES PADDING IF V_FILE_PTRS are 8 bytes\nV_FILE_PTR(level_mesh_posdummy *) m_posdummies;\net_int32                m_num_occluders;\n// 4 BYTES PADDING\nV_WIDE_PTR(level_mesh_occluder *) m_occluders;  // Using a wide ptr here to make decrementing pad bytes simpler.\nV_FILE_PTR(rl_multi_mesh_data*) m_multi_mesh_lod;\net_fl_vector                m_collision_bmin;\net_fl_vector                m_collision_bmax;\n// default values for when no variants are provided\net_uint                        m_num_material_variants;\nV_WIDE_PTR(level_mesh_material_variant *) m_material_variants;\net_uint                        m_num_variant_values;\nV_WIDE_PTR(level_mesh_variant_value *) m_variant_values;\n// crc maps for each lod\net_uint                        m_this_lod_map_index;\net_uint                        m_num_variant_crc_maps;\nV_WIDE_PTR(et_uint*)        m_variant_crc_maps_counts;                     V_WIDE_PTR(V_WIDE_PTR(et_uint32 *)*) m_variant_crc_maps;\n// for keeping track to duplicate references in the level_mesh_lod_array code\nV_WIDE_PTR(level_mesh_header*) next;\nV_WIDE_PTR(level_mesh_header*) prev;\nvolatile uint32            m_preload_done;\nuint8                            m_pad_bytes[16];        // will always be zeroed.  Use this space for easier versioning of header.\n};\n</code></pre></p> <p>matlib files have a v file header, then this header: <pre><code>struct material_library {\net_uint32                    m_signature;\net_uint32                    m_version;\n// RL data\nV_FILE_PTR(rl_material_map *) m_material_map;\nV_FILE_PTR(V_FILE_PTR(rl_static_material *) *) m_materials;\net_uint                                m_num_materials;\n// 4 BYTES PAD IF V_FILE_PTRS ARE 8 BYTES\nV_FILE_PTR(char const *)        m_texture_names;\n// in the 1:1 file the following are tagged on\n// &lt;&lt; material data\n};\n</code></pre></p> <p>The actual material data structure looks like this: <pre><code>struct rl_material_const {\net_float                    elem[4];\n};\n// 1:1 data structure for writing texture descs to disk\n//\nstruct rl_material_texture_desc {\nrl_texture_handle        texture_handle;\net_uint32                name_checksum; //the crc_stri() of the name of the texture semantic in the shader file, not the texture filename\net_uint16                texture_stage;\net_uint16                texture_flags;\n};\n// 1:1 data structure for writing materials to disk\n//\nstruct rl_material_data {\nrl_shader_handle                shader_handle;\net_uint32                        name_checksum;\n// flags for the material see the RLMF_* defines\net_uint32                        mat_flags;\n// packed into 4 bytes\net_uint16                        num_textures;\nuint8                                num_constants; // the number of quadwords in the constant block\nuint8                                max_constants; // the actual space allocated (extra space for adding constants in shaders at runtime)\nV_FILE_PTR(rl_material_texture_desc *)    textures;\nV_FILE_PTR(et_uint32 *)                constant_name_checksum; // array of crc`s of the constant names in the shader file\nV_FILE_PTR(rl_material_const *)    constant_block;             // the pointer to the block of data that get's upload to the user constants\n//                    There is no need to store the alpha version of a shader in a material... a material is either alpha or not alpha.  So in the case of an alpha\n//                     material, the shader handle will point to the alpha version of the inferred lighting shader.  Only keeping the below field around until the next\n//                     global recrunch.\nrl_shader_handle                alpha_shader_handle;         // shader handle for alpha version of shader (only used with inferred rendering)\n};\n</code></pre></p>"},{"location":"SRTT/formats/","title":"Formats","text":"Name Ext. Description Tools Mesh <code>.cmesh_pc</code> <code>.g_cmesh_pc</code> <code>.smesh_pc</code> <code>.g_smesh_pc</code> Character mesh <code>.ccmesh_pc``.csmesh_pc</code> Level mesh <code>.clmesh_pc``.glmesh_pc</code> Packfile <code>.vpp_pc</code> File container archive <code>minimaul's tools</code> Streamfile <code>.str2_pc</code> Streaming archive <code>minimaul's tools</code> Assembly file <code>.asm_pc</code> For streamfiles <code>minimaul's tools</code> Pegfile <code>.peg_pc</code> <code>.g_peg_pc</code> Image data Table <code>.tbl</code> XML Table <code>.xtbl</code> Zonefile <code>.czh_pc</code> <code>.czh_pc</code> <code>quantum_sr_zone_tools</code>"},{"location":"SRTT/formats/anim/","title":"Animation","text":"<p>Look at SRIV equivalent, it's probably similar.</p>"},{"location":"SRTT/formats/common/","title":"Common","text":"Links <ul> <li>Kinzie's Toy Box | File Formats</li> </ul>"},{"location":"SRTT/formats/common/#v_file_header","title":"v_file_header","text":"<p>This header is slapped on quite a few, but not all files. <pre><code>struct v_file_header\n{\net_uint16        m_signature;   // binary file signature\net_uint16        m_version;     // file version\net_uint32        m_reference_data_size;     // size of reference data\net_uint32        m_reference_data_start;    // offset to reference data\net_uint32        m_reference_count;         // number of references in header\nuint8            m_initialized; // whether this header has been initialized.\nuint8            m_pad[15];     // extra pad data, zero'd before write\n}; </code></pre></p>"},{"location":"SRTT/formats/meshes/","title":"Meshes","text":"<p>File extensions</p> <p><code>.ccmesh_pc</code> <code>.csmesh_pc</code> <code>.gsmesh_pc</code> <code>.clmesh_pc</code> <code>.glmesh_pc</code> <code>.rig_pc</code></p> Links <ul> <li>https://www.saintsrowmods.com/forum/threads/peg-file-format.2908/</li> </ul> Tools <p>-</p> <p>Look at SRIV equivalent, it's probably similar.</p>"},{"location":"SRTT/formats/meshes/#ccmesh_pc","title":".ccmesh_pc","text":"<p>Characters</p>"},{"location":"SRTT/formats/meshes/#clmesh_pc","title":".clmesh_pc","text":"<p>Static world models Seem to contain havok collisions</p> KSY <pre><code>meta:\nid: srtt_clmesh_pc\nfile-extension: clmesh_pc\nendian: le\nencoding: utf-8\ndoc: |\nSRTT Level Mesh Header\nVery, very WIP\nseq:\n- id: file_header\ntype: v_file_header\n- id: texture_names\ntype: strz\nrepeat: expr\nrepeat-expr: file_header.reference_count\n- size: 1\n- type: align(16)\n- id: level_mesh_headerr\ntype: level_mesh_header\n#- id: unk1\n#  type: u4\n#- id: unk2\n#  type: u4\n#contents: [20,0,0,0]\n#- id: unk3\n#  type: u4\n- id: unk4\ntype: f4\nrepeat: expr\nrepeat-expr: 15\n- id: unk5\ntype: s4\n- contents: [-1,-1,-1,-1]\n- size: 64\n- id: unk6\ntype: f4\nrepeat: expr\nrepeat-expr: 6\n- size: 32\n- id: unk7\ntype: u4\n- id: unk8\ntype: u4\n- size: 96\n- id: unk9\ntype: u4\n- id: unk10\ntype: u4\ntypes:\nalign:\ndoc: |\nByte alignment tool\nparams:\n- id: size\ntype: u4\nseq:\n- size: (size - _io.pos) % size\nv_file_header:\ndoc: |\nStandard Volition file header\nseq:\n- id: signature\ntype: u2\n- id: version\ntype: u2\n- id: reference_data_size\ntype: u4\n- id: reference_data_start\ntype: u4\n- id: reference_count\ntype: u4\n- id: initialized\ntype: u1\n- size: 15\nfl_vector:\nseq:\n- id: x\ntype: f4\n- id: y\ntype: f4\n- id: z\ntype: f4\nbbox:\nseq:\n- id: min\ntype: fl_vector\n- id: max\ntype: fl_vector\nlevel_mesh_header:\ndoc: |\nThis is a guess based on SRIV docs\nseq:\n- id: signature\ntype: u4\n- id: version\ntype: u2\n- size: 2\n- id: mesh_flags\ndoc: probably\ntype: u4\n- id: bounding_center\ntype: fl_vector\n- id: bounding_radius\ntype: f4\n- id: unk2\ntype: f4\n- id: unk3\ntype: f4\n- id: local_aabb\ntype: bbox\n</code></pre>"},{"location":"SRTT/formats/meshes/#glmesh_pc","title":".glmesh_pc","text":"<p>Static world models</p>"},{"location":"SRTT/formats/peg/","title":"Pegfiles","text":"<p>File extensions</p> <p><code>cvbm_pc</code> <code>gvbm_pc</code> <code>cpeg_pc</code> <code>gpeg_pc</code></p> Links <ul> <li>https://www.saintsrowmods.com/forum/threads/peg-file-format.2908/</li> </ul> Tools <p>-</p> <p>Pegleg image format \u26f5\ud83c\udff4\u200d\u2620\ufe0f</p> peg_header<pre><code>struct VLIB_EXPORT peg_header {\nint32      signature;\nint16      version;\nint16      platform;            // see peg_platform enum\nint32      dir_block_size;         // calculated by bm_save_peg(). includes size of header, plus padding.\nint32      data_block_size;       // calculated by bm_save_peg(). includes padding the allocator might have done.\nint16      num_bitmaps;\nint16      flags;\nint16      total_entries;\nint16      align_value;\npeg_entry  peg_entries[0];          // Can use this to access the entries\n};\n</code></pre> <p>Then the peg entry itself(one in a vbm file, multiple in a peg)</p> peg_entry<pre><code>struct peg_entry {\nuint8         *data;  // written to disk as offset from start of file.\nuint16        width;\nuint16        height;\nuint16        bm_fmt;\nuint16        pal_fmt;\nuint16        anim_tiles_width;  // for animated textures using an anim sheet BM_F_ANIM_SHEET\nuint16        anim_tiles_height;\nuint16        num_frames;\nuint16        flags;        // see BM_F_* defines   \nchar          *filename;\nuint16        pal_size;\nuint8         fps;\nuint8         mip_levels;  // Base frame + number of mipmaps (always at least 1)\nuint32        frame_size;  // Bytes in palette + image.\npeg_entry     *next;        // each base bitmap_entry will maintain a linked list of\npeg_entry     *prev;        // actual peg entries so we can do unloading of pegs very quickly\nuint32        cache[2];    // generic texture caching data, used differently on different platforms\n};\n</code></pre> Flags<pre><code>#define BM_F_ALPHA              (1&lt;&lt;0)  // bitmap has alpha\n#define BM_F_NONPOW2            (1&lt;&lt;1)  // bitmap is not power of 2\n#define BM_F_ALPHA_TEST         (1&lt;&lt;2)\n#define BM_F_CUBE_MAP           (1&lt;&lt;3)  // bitmap is a cube map, react appropriately on load.\n#define BM_F_INTERLEAVED_MIPS   (1&lt;&lt;4)  // bitmap contains interleaved mips (they exist inside of the NEXT bitmap)\n#define BM_F_INTERLEAVED_DATA   (1&lt;&lt;5)  // bitmap contains interleaved mips from the previous bitmap\n#define BM_F_DEBUG_DATA_COPIED  (1&lt;&lt;6)  // used by the peg assembler only.\n#define BM_F_DYNAMIC            (1&lt;&lt;7)  // bitmap was loaded dynamically (not from a peg) (runtime only)\n#define BM_F_ANIM_SHEET         (1&lt;&lt;8)  // bitmap animation frames are stored in one bitmap spaced sequentially left to right\n#define BM_F_LINEAR_COLOR_SPACE (1&lt;&lt;9)  // bitmap is NOT stored in SRGB space, it is linear\n#define BM_F_HIGH_MIP           (1&lt;&lt;10) // bitmap is a separately streamed high mip\n#define BM_F_HIGH_MIP_ELIGIBLE  (1&lt;&lt;11) // bitmap is eligible for linking up with a high mip (runtime only flag)\n#define BM_F_LINKED_TO_HIGH_MIP (1&lt;&lt;12) // bitmap is currently linked to a high mip (runtime only flag)\n#define BM_F_PERM_REGISTERED    (1&lt;&lt;13) // bitmap is permanently registered. used on the PC so d3d becomes the permanent owner of the texture memory.\n</code></pre> bm_fmt values of interest<pre><code>   BM_FORMAT_PC_DXT1                                = 400,\nBM_FORMAT_PC_DXT3,\nBM_FORMAT_PC_DXT5,\nBM_FORMAT_PC_565,\nBM_FORMAT_PC_1555,\nBM_FORMAT_PC_4444,\nBM_FORMAT_PC_888,\nBM_FORMAT_PC_8888,\nBM_FORMAT_PC_16_DUDV,\nBM_FORMAT_PC_16_DOT3_COMPRESSED,\nBM_FORMAT_PC_A8,\n</code></pre>"},{"location":"SRTT/formats/vpp/","title":"Packfiles and ASM","text":"<p>File extensions</p> <p><code>.vpp_pc</code></p> Links <ul> <li>https://www.saintsrowmods.com/forum/threads/asm-and-vpp-file-formats.8448/</li> </ul> Tools <p>minimauls tools</p>"},{"location":"SRTT/formats/vpp/#packfile","title":"Packfile","text":"<p>Packfiles consist of a big header on top followed by invdividual entries. The header is actually different pieces aligned to 2048 bytes for historical cd drive reasons. We start with the v_packfile structure itself followed by the directory(v_packfile_entries) and that is followed by the filename list. We convert the pointers to offsets into the filename pool when writing to disk.</p> <pre><code>struct v_packfile_entry {\nchar                        *filename;         // filename\nuint32                      sector;            // sector offset RELATIVE to the start of the packfile\nuint32                      start;             // offset from start of v_packfile::data (if data is valid)\nuint32                      size;              // file size\nuint32                      compressed_size;   // compressed file size\nstruct v_packfile           *parent;           // my parent\n};\n</code></pre> <pre><code>struct v_packfile {\nuint32            descriptor;        // packfile descriptor used to validate data\nuint32            version;           // version number of packfile\nchar              short_name[V_MAX_PACKFILE_NAME_LEN+1];  // filename - 8.3 format\nchar              pathname[V_PACK_MAX_PATH_LEN+1];        // pathname\nuint32            flags;             // packfile flags\nuint32            sector;            // packfile starts at this sector\nuint32            num_files;         // number of files in *data section\nuint32            file_size;         // physical size (in bytes) of the source vpp file\nuint32            dir_size;          // number of bytes in directory section\nuint32            filename_size;     // number of bytes in filename section\nuint32            data_size;         // number of uncompressed bytes in data files\nuint32            compressed_data_size; // number of compressed bytes in *data section\nv_packfile_entry  *dir;              // directory section\nchar              *filenames;        // file name section\nuint8             *data;             // data section -- set gameside when a packfile is wholely loaded into memory (temp, condensed, or memory mapped)\nuint32            open_count;        // how many files have open handles into the packfile\n};\n</code></pre>"},{"location":"SRTT/formats/vpp/#asm","title":"ASM","text":"<p>This is the file for streaming purposes that describes the resources required to load a \"thing\".</p> <p>We start with a container(thing) header: <pre><code>struct stream2_container_header {\nuint32    signature;\nuint16    version;\nuint16    num_containers;   };\n</code></pre> This is followed by some mappings for allocators, primitives(files), and containers so we can move things around internally and still match up to the enums: <pre><code>int32  num_allocator_remaps\nchar *name\nuint8 stored_index\nint32  num_primitive_remaps\nchar *name\nuint8 stored_index\nint32  num_container_remaps\nchar *name\nuint8 stored_index\n</code></pre></p> <p>We then read each container from the asm file and they look like this when stored: <pre><code>struct stored_container {\nchar   *name;\nuint8  container_type;\nuint16 load_flags;\nint16  num_entries;\nuint32 packfile_base_offset;\nchar   *stub_parent_name;\nint32  aux_data_size;\nuint8  *aux_data;\nint32  packfile_total_compressed_read_size;\n}\n</code></pre> This is followed by num_entries * 2 uint32's which are the file sizes for the entries in the packfile. Next we spin through each entry and load it: <pre><code>struct stored_primitive {\nchar  *name;\nuint8 primitive_type;\nuint8 allocator;\nuint8 flags;\nuint8 split_extension_index;\nint32 cpu_size;\nint32 gpu_size;\nuint8 allocation_group;\n}\n</code></pre></p>"},{"location":"SRTT/formats/vpp/#notes","title":"Notes:","text":"<ul> <li>filename like strings are usually stored by writing the length of the string as a uint16 and then the string bytes themselves.</li> <li>a primitive type can have multiple extensions. Something like a texture can be a vbm or a peg, so we need to keep track of which it is so we can substitute the correct gpu extension without having to do something like a string compare. That is what the split_extension_index value is. It stores to which set of extensions this file belongs.</li> <li>primitive types are just statically assigned values</li> <li>auxilary data is random data to attach to a container. We use that for zpp files I believe, but the streaming system just stores bytes and doesn't interpret it at all.</li> </ul>"},{"location":"SRTT/formats/zone/","title":"Zone files","text":"<p>File extensions</p> <p><code>.czh_pc</code> <code>.czn_pc</code> </p> Links <ul> <li>[V] Knobby | SR3 zone file format</li> <li>Kinzie's Toy Box | File Formats</li> </ul> Tools <p><code>quantum_sr_zone_tools</code></p> <p>The zone file is split up into a header(czh file) and the zone data itself (czn file). We did this to save memory since we only need the header portion for building streaming containers and at load time. We load and then dump this header data.</p> <p>There is a <code>v_file_header</code> on top of the czh that describes the things that the zone references. This will be things like textures and meshes and they end up in the str2 file.</p> v_file_header<pre><code>uint16 signature - 0x3854\nuint16 version - 4\nuint32 reference_data_size\nuint32 reference_data_start(offset)\nuint32 reference_count - number of references in the file\nuint8 pad[16] - zero'd before write, padding so we can add to the header\n</code></pre> <p>Reference data always follows the header. That data starts at reference_data_start offset from the top of the v_file_header and to get to the next reference(string) you just advance past the string. Double null termination on this string list, but the size is known as well.</p> <p>Immediately following the v_file_header is the world zone header: world_zone_header<pre><code>// Header for zones\nstruct world_zone_header {\n// 8 bytes \net_uint32   m_signature;   // 'Z3RS'\net_uint32   m_version;     // 29\n// 4/8 bytes, 8 on PC, points back up into the v_file_header since we use that at load time to find filenames(saving some space)\nconst struct v_file_header *m_v_file_header;    // Filled in at load time, \net_fl_vector        m_file_reference_offset;    // position offset to apply to all file refs\nwz_file_reference   *m_file_references;     // Filled in at load time\net_uint16           m_num_file_references;  // number of file references\nuint8               m_zone_type;    // type of zone\nuint8               m_unused;       // pad previous to two bytes\nwz_interior_trigger *m_interior_triggers;       // filled in at load time\net_uint16           m_num_interior_triggers;    // filled in at load time\nuint16              m_extra_objects;  // only in test levels(not sure for what)\nuint8               m_pad[24]; // Pad for future use, guaranteed to be zero'd\n};\n</code></pre></p> enum zone_types <pre><code>// Types of zones\nenum world_zone_types {\nWZT_UNKNOWN = 0,\nWZT_ALWAYS_LOADED,\nWZT_STREAMING,\nWZT_STREAMING_AL,\nWZT_TEST_LEVEL,\nWZT_MISSION,\nWZT_ACTIVITY,\nWZT_INTERIOR,\nWZT_INTERIOR_AL,\nWZT_TEST_LEVEL_AL,\nWZT_MISSION_AL,\nWZT_HIGH_LOD,\nNUM_WORLD_ZONE_TYPES\n};\n</code></pre> <p>[V] Knobby said: Some information about these: We have 2 distinct types of worlds that we load in SR3/4. We have a test level, which is a single zone of arbitrary size and then we have a streaming level which is broken up into pieces. We also have a global always loaded(WZT_ALWAYS_LOADED) named after the world and then individual always loaded files for each zone(WZT_STREAMING_AL). Missions and activities have a big \"zone\" that is loaded when the mission or activity is active. They can also have an always loaded portion.</p> Position offsets <p>[V] Knobby said:  </p> <p>Quantum said: The coordinates in the world zone mesh file references are of type \"et_int16\" (16 bit values). I am displaying them as integers, but is there a factor I can apply that will translate them to standard game coordinate units?</p> <p>We use the following to get an absolute position. Since the position is inside the zone, we add the reference position to it to get world offset:</p> <pre><code> // transform of the instance\nfl_matrix43 transform;\nref-&gt;m_transform.get(transform);\ntransform.m_translation += header-&gt;m_file_reference_offset\n</code></pre> <p>In the zone file itself we find a chunked format. It is a series of sections of data each with a header that describes the content. A section header looks like this: <pre><code>struct zone_section {\net_uint32   m_id; // highest bit is a flag that tells us if the section has a gpu size. This flag is masked off after storing if the gpu size is to be expected.\net_uint32   m_cpu_size; // cpu size of this section (does not include the header which is variable size)\net_uint32   m_gpu_size; // if (gpu flag set\n}\n</code></pre></p> <pre><code>struct wz_file_reference {\net_int16 m_pos_x;\net_int16 m_pos_y;\net_int16 m_pos_z;\net_int16 m_pitch;\net_int16 m_bank;\net_int16 m_heading;\n// offset into v_file_header string pool for the filename\net_uint16 m_str_offset;\n}\n</code></pre> <pre><code>Section ids:\n0x2233 - crunched reference geometry - transforms and things for level meshes\n0x2234 - objects - nav points, environmental effects, and many, many more things\n0x2235 - navmesh\n0x2236 - traffic data\n0x2237 - world editor generated geometry - things directly made from the editor like terrain\n0x2238 - sidewalk data\n0x2239 - section trailer (??)\n0x2240 - light clip meshes\n0x2241 - traffic signal data\n0x2242 - mover constraint data\n0x2243 - zone triggers(interiors, missions)\n0x2244 - heightmap\n0x2245 - cobject rbb tree - cobjects are things that are not a full on object like tables and chairs\n0x2246 - undergrowth - foliage\n0x2247 - water volumes\n0x2248 - wave killers\n0x2249 - water surfaces\n0x2250 - parking data\n0x2251 - rain killers\n0x2252 - level mesh supplemental lod data\n0x2253 - cobject grid data - object fading\n0x2254 - ae rbb (??)\n0x2255 - havok pathfinding data(SR4 only?)\n</code></pre> <p>Object Section Data Object header data on top: <pre><code>uint32  signature           // 0x574F4246\nuint32  version             // 5\nint32   num_objects\nint32   num_handles\nuint32  flags\nuint64  *handle list        // run-time\nuint8   *object data        // run-time\nuint32  object data size    // run-time\n</code></pre></p> <p>Header is followed immediately by handle list(64 bit handles), which is followed by object data.</p> <p>The data is a series of property blocks: <pre><code>uint32  *handle                 // offset on disk\nuint32  *parent handle          // offset on disk\nuint32  object type hash        uint16  number_of _properties\nuint16  buffer size\nuint16  name offset             // offset into the property list for the name of the object\nuint16  padding\n</code></pre> rest of the data is the property list itself. This is different data for each object, but the property list is just: <pre><code>uint16 type\nuint16 size\nuint32 name crc\n</code></pre> followed by data. We store enumerations, flag data, strings, binary buffers, transforms, and other things in here and each object type looks for specific data based on that object.</p> <p>type values are: <pre><code>0 - string\n1 - data\n2 - compressed transform - pos only(fl_vector)\n3 - compressed transform with quaternion orient (fl_vector pos followed by fl_quaternion for orient)\n</code></pre></p> <p>fl_quaternion is a fancy want to compress data. It is a x, y, z, w float that represents a roation.</p>"},{"location":"SRTT/lua/","title":"Lua","text":"<p>TODO: Pull all lua reference</p>"},{"location":"tools/cmesh2obj/","title":"cmesh2obj","text":"<p>Links <code>Forum Post</code></p> <p>Games <code>SR2</code></p> <p>File formats <code>.cmesh_pc</code> <code>.g_cmesh_pc</code> <code>.cmesh_pc</code> <code>.g_cmesh_pc</code> <code>.car_pc</code></p> <p>Dropoff's Saints Row 2 Models Export Tool</p>"},{"location":"tools/minimauls_tools/","title":"Minimaul's tools","text":"<p>Links <code>Forum Post</code></p> <p>Games <code>SR2</code> <code>SRTT</code> <code>SRIV</code> <code>GOOH</code></p> <p>File formats <code>.asm_pc</code> <code>.str2_pc</code> <code>.vpp_pc</code> <code>.bnk_pc</code> <code>.sim_pc</code></p> <p>Minimaul's Saints Row 2, Saints Row: The Third, Saints Row IV and Gat Out Of Hell tools</p>"},{"location":"tools/quantum_sr_zone_tools/","title":"quantum_sr_zone_tools","text":"<p>Links <code>Forum Post</code> <code>GitHub</code></p> <p>Games <code>SRTT</code> <code>SRIV</code></p> <p>File formats <code>.czh_pc</code> <code>.czn_pc</code></p> <p>Quantum's SRTT &amp; SRIV zone file tools</p>"},{"location":"tools/quantum_sr_zone_tools/#included-tools","title":"Included Tools","text":""},{"location":"tools/quantum_sr_zone_tools/#srreadzoneexe","title":"SRReadZone.exe","text":"<p>Parses and displays the contents of a zone header file and the corresponding zone data file. Type the command with no parameters to display a usage message.\u200b</p>"},{"location":"tools/quantum_sr_zone_tools/#srzonetoolexe","title":"SRZoneTool.exe","text":"<p>Converts zone files to and from XML format. Type the command with no parameters to display a usage message. For more information about this tool, see the \"SRZoneTool.html\" document included in this package.\u200b</p>"},{"location":"tools/quantum_sr_zone_tools/#srzonefinderexe","title":"SRZoneFinder.exe","text":"<p>Finds zone files closest to a set of coordinates. Type the command with no parameters to display a usage message.\u200b</p>"},{"location":"tools/quantum_sr_zone_tools/#srpatchfileexe","title":"SRPatchFile.exe","text":"<p>Writes one or more bytes to specific locations in an existing file. Great for scripting!\u200b</p>"},{"location":"tools/sr2_chonker/","title":"SR2 Chonker","text":"<p>Links <code>Forum Post</code> <code>GitHub</code></p> <p>Games <code>SR2</code></p> <p>File formats <code>.chunk_pc</code> <code>.g_chunk_pc</code> </p> <p>M\u00f6yh M\u00e4yhem's tool for viewing and tampering with SR2 maps.</p>"},{"location":"tools/sr2chunkstexturetool/","title":"SR2 ChunksTextureTool","text":"<p>Links <code>Forum Post</code></p> <p>Games <code>SR2</code></p> <p>File formats <code>.peg_pc</code> <code>.g_peg_pc</code> <code>.chunk_pc</code></p> <p>Masamaru's Saints Row 2 Chunks Texture Tool</p>"},{"location":"tools/sr2ctsmapper/","title":"SR2 CTS Mapper","text":"<p>Links <code>Forum Post</code></p> <p>Games <code>SR2</code></p> <p>File formats <code>.cts</code></p> <p>Masamaru's Saints Row 2 cts mapper</p>"},{"location":"tools/sr2pegtool/","title":"SR2 PegTool","text":"<p>Links <code>Forum Post</code></p> <p>Games <code>SR2</code></p> <p>File formats <code>.peg_pc</code> <code>.g_peg_pc</code></p> <p>Masamaru's Saints Row 2 Peg Texture Tool</p>"}]}